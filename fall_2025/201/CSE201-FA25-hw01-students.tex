\documentclass[letterpaper,12pt]{article}
\usepackage[scale={0.8,0.9},centering,includeheadfoot,dvips, nohead]{geometry}
\usepackage[obeyspaces,spaces]{url}
\usepackage{amsmath}
% \usepackage{algorithm}
\usepackage{algpseudocodex}
\usepackage{hyperref}

\pagestyle{empty}

\newcommand{\abs}[1]{\left\vert #1 \right\vert}


% Type 1: no solution 
% Type 2: with solution
% Type 3: with solution + details for TA/instructor



%\newcommand{\ShowSolution}{2}
%\newcommand{\solution}[1]{\ifthenelse{\equal{1}{\ShowSolution}}{\textbf{Sol.} #1}{}}
%\newcommand{\rubric}[1]{\ifthenelse{\equal{1}{\ShowSolution}}{\textbf{Rubric.} #1}{}}



\newcommand{\rub}{\paragraph{Rubric.}}
\newcommand{\sol}{\textbf{Sol.\hspace{0.5cm}}}



\begin{document}


\noindent
 UCSC CSE201 Homework 1 \hfill Fall 2025 \\
Last update: 10/1/2025 \\
 \rule{\textwidth}{0.5pt}

% \input{../preamble}

\enlargethispage*{1.5cm}

\noindent
 \rule{\textwidth}{0.5pt}




\begin{enumerate}

\item Type that ``I thoroughly read the course syllabus" to acknowledge that your did so. 

I thoroughly read the course syllabus


\item
Consider the recurrence relation
$F(0)=F(1)=2$ and for $n>1$
$$F(n)= \sum_{i=1}^{n-1} F(i) F(i-1)$$
We consider the problem of computing $F(n)$ from $n$.

\begin{enumerate}


\item
Show that a naive implementation of this recursion takes an exponential time in $n$. In other words,
show that the run time is $\Omega(c^n)$ for some constant $c  > 1$.

\textbf{solution}

note that \begin{equation}\begin{split}
        T(n) &= T(n-1) + T(n-2) +1\approx 2T(n-2)+1\\
        &= 2\cdot 2 T(n-4)+1\\
        &= 2^m T(n-2m)+1
\end{split}
\end{equation}

the plus one represents the constant time required to  call the function.

we can it takes \(2^m\) time to run, but only ends when \(m=n\), thus it takes approximately \(2^n\) time to run.







\item Explain how, by not recomputing the same $F(i)$ value twice (i.e., using dynamic programming),
one can obtain an algorithm for this problem that runs in $O(n^2)$ 
time. 

\textbf{solution}

we want A[i] = F[i]F[i-1]

\begin{algorithmic}[1]\label{algo1.1}
    \State A is a list of len n, init to 0
    \State F is a list of len n, init to 0
    \State F[0] = F[1] = 2 
    \State A[1] = \(2\cdot 2\)
    \For {i in \(\{2,\dots,n\}\)}\label{1.1}
        \State A[i]= F[i-1] + F[i-2]
        \For {j in \(\{1,\dots,i\}\)}\label{1.2}
            \State F[i]+=A[j]
        \EndFor
    \EndFor
    \State \Return F[n]
\end{algorithmic}

note the loop on line~\ref{1.1} iterates n times, and within it line ~\ref{1.2} iterates \(n\) times as well, thus the program runs in \(n^2\) time


\item
Give an algorithm for this problem that only has $O(n)$ 
run time. 

\textbf{solution}

% G[j] \(n\in \{2,\dots,n\}\) is \begin{equation}
%     \sum_{i=1}^{j-1} A[i]
% \end{equation}

% \begin{algorithmic}
%     \State A is a list of len n, init to 0
%     \State F is a list of len n, init to 0
%     \State G is a list of len n, init to 0
%     \State F[0] = F[1] = 2 
%     \State A[1] = 2\cdot 2
%     \State G[2] = A[1]
%     \For {i in \(\{2,\dots,n\}\)}\label{1.2.1}
%         \State A[i]= F[i-1] + F[i-2]
%         \State G[i]
%     \EndFor
%     \State \Return F[n]
% \end{algorithmic}




if we store all \(F[i]\), then finding the next term takes \(O(1)\) since it requires computing one extra term, which takes 

\begin{algorithmic}[1]
    \State A is a list of len n, init to 0
    \State F is a list of len n, init to 0
    \State F[0] = F[1] = 2 
    \State A[1] = \(2\cdot 2\)
    \For{i in \(\{2,\dots,n\}\)}\label{1.2.1}
        \State A[i] = F[i-1] + F[i-2]
        \State F[i] = F[i-1] + A[i]
    \EndFor
    \State \Return F[n]
\end{algorithmic}

this removes one loop~\ref{1.2} in~\hyperref[algo1.1]{algo 1} thus it runs in \(O(n)\)


\end{enumerate}



\item Informally in this problem we consider how to divide the chapters in a story into volumes (think the 7 volumes of Harry Potter
or however many Game of Thrones volumes there will be) so as to equalize the size of the volumes. 
The input consists of positive integers $x_1, \ldots, x_n$ and $k$. Here $x_i$ is the number of pages in chapter $i$, and $k$ is the desired number of volumes. The problem is determine which chapters go
into each of the $k$ volumes so as to minimize the difference between the most number of pages in
any volumes, and the least number of pages in any of the volumes. Of course you can not reorder the story. 
Give an algorithm whose running time is bounded by a  polynomial in $n$. You running time should not
depend on the number of pages in the chapters. 


\smallskip
\begin{quote}
Hint: This approach prioritizes simplicity over optimal runtime.

A volume is composed of a contiguous subset of chapters, so its total page count belongs to the set:
\[
P := \left\{ \sum_{i=a}^{b} x_i \mid 1 \le a \le b \le n \right\}
\]
Consider every pair of values $(L, H)$ from this set such that $L \le H$. For each pair, check if it's possible to partition the chapters into exactly $k$ volumes, where each volume's page count is between $L$ and $H$. We call such a pair $(L, H)$ a \textbf{feasible pair}. The goal is to find a feasible pair $(L, H)$ that minimizes the difference $H-L$. 

\end{quote}

\begin{enumerate}
\item Give a polytime algorithm to determine if a given pair $(L, H)$ is feasible (assume $L, H >0 $. Explain why the run time is polynomial in $n$. Be concise. 


\textbf{Solution}

% note this solution finds the answer for both parts (a) and (b)



\begin{algorithmic}[1]
    \State \(S[i] = \sum_{a=1}^i x_a\)
    \State new array A, size k by n. set all values to []
    \For{\(j\in \{1,\dots,n\}\)} \label{line:init}
        \If{L\(\leq\)S[j]\(\leq\)H }
            \State A[0][j].append(0)
        \EndIf
    \EndFor
    \For{\(i \in \{0,\dots,k-1\}\)} \label{line:startl}
        \For{\(j\in \{1,\dots,n\}\)}
            \If{A[i][j] is nonempty}
                \For{\(k\in\{j+1,\dots,n\}\)}
                    \If{\(L\leq S[k]-S[j]\leq H\)}
                        \State A[i+1][k].append(j)
                    \EndIf
                \EndFor
            \EndIf
        \EndFor
    \EndFor\label{line:endl}
    \If{A[-1][-1] is nonempty}
        \State \Return True
    \EndIf
    \State \Return False
\end{algorithmic}

note that  \(S[a]-S[b]\) is the number of pages between the chapters b to a.

step~\ref{line:init} is initializing the first row of A. the loop determines if the chapter \(j\) can be in the 1st volume. the each row of A is answering the question, is it possible for this chapter to be in the \(i+1\)th volume

the loop from step~\ref{line:startl} to~\ref{line:endl} is answering, if the volume started at chapter \(j\), is it possible for chapter \(k\) to be in book \(i+1\). 

the for loop on step 6 contributes a constant time since k is fixed. the for loop on step 7 contributes \(O(n)\), and the for loop on 9 also contributes \(O(n)\), thus teh total loop on steps 6 to 11 run in \(O(n^2)\) time. 





\item Given a feasible pair $(L, H)$, explain how to find a partitioning of chapters into $k$ volumes so that every volume's page count is between $L$ and $H$. 

\textbf{Solution}

starting from A[-1][-1], pick any element \(a\) inside that array. \(a+1\) to the final chapter forms the final book. repeat the same process from A[-2][a] until you reach the final row, in which you make sure you start from the 1st chapter. 

There must exist a path because it was necessary for A[-1][-1] to be nonempty

% looking at the array \(A\) from part (a), 

% given a feasable pair,


\end{enumerate}


    







\item 
Consider the problem where the input is a collection of $n$ train
trips within Germany. For the $i$th trip $T_i$ you are given the date $d_i$ of
that trip, and the non-discounted fare $f_i$ for that trip.
The German railway system sells a Bahncard for $B$ Euros that
entitles you to a 50\% fare reduction on all train travel
within Germany within $L$ days of purchase.
The problem is to determine when to buy a Bahncard to minimize the
total cost of your travel.
 
For example if the input was \\
$d_1$ = January 11, 1997, $f_1=20$ Euros, \\
$d_2$ = February 11, 1998, $f_2=200$ Euros, \\
$d_3$ = January 11, 1999, $f_3=200$ Euros, \\
$d_4$ = March 13, 1999, $f_4=100$ Euros, \\
$d_5$ = February 11, 2002, $f_5=200$ Euros, and \\
$d_6$ = January 11, 2003, $f_6=600$ Euros, $B=240$\\
, and $L=365$ then
you might buy a Bahncard on February 11, 1998, and
February 11, 2002, resulting in a total cost of
1200 Euros (240 * 2 + 20 + (200 + 200) * 0.5 + 100 + (200+ 600) * 0.5). If you only purchase a Bahncard on 
February 11, 2002, you would pay a total of 1160 Euros (240 + 20 + 200 + 200 + 100 + (200+ 600) * 0.5).
 
Give a polynomial time algorithm for this problem.
The running time of your algorithm should be independent of
$B$ and $L$. For convenience, assume that the dates are given as integers, and 
$d_1 = 1 < d_2 < d_3 < \ldots$. 



\textbf{solution}

% consider a matrix \(C\) w dimension \(n\times n\) where \(n\) is the total number of trips. the first index \(i\) represents the price of the first \(i\) trips, given that the last pass was bought on the second index \(j\). 

% note for 
% \begin{equation}
%     C[j][i] = \min_{j^\prime < i}(C[i-1][j^\prime]) + B + 0.5 \sum_{i^\prime=j+1}^{i}\delta(i^\prime,j) d_i + \sum_{i^\prime=j+1}^{i}\delta'(i^\prime,j) d_i 
% \end{equation}

% where \(\delta(i,j)\) is the indicator function for when a trip i is within the card timeframe of j--that is \(0\leq d_i-d_j\leq L\)--and \(\delta^\prime(i,j)\) is the indicator function for when the trip is outside the timeframe of a card bought at trip j, \(d_i-d_j\leq0  \lor L\leq d_i-d_j\).



consider an array \(A\) of length \(n\). initialize to 0.

also consider array \(B\) which holds bools, and \(C\) which holds ints initialized to 0. 

start from \(A[-1]\) this is the base case which is initialized to 
\begin{equation}
    \min\left(p_{-1},B+\frac{p_{-1}}{2}\right)
\end{equation}

incrementing backwards, we find that 
\begin{equation}\label{3.1}
    A[-i] = \min\left(p_{-i}+A[-i+1],B+0.5\sum_{i^\prime = i}^{n}p_{i^\prime}\delta(i,i^\prime)+A[f(i)+1]\right)
\end{equation}

where \(\delta(i,j)\) is the indicator function defined as
\begin{equation}
    \delta(i,j)=\begin{cases}
        1 &0\leq d_j-d_i\leq L\\
        0& \text{else}\\
    \end{cases}
\end{equation}

and
\begin{equation}
    f(i) = j, (0\leq d_j-d_i\leq L) \land (d_{j+1}-d_i>L)
\end{equation}

when the first option in eq~\ref{3.1} is choosen, set \(B[-i]\) to false (denoting that the card was not bought) and \(C[-i]\) remains 0. if the second option is choosen, set \(B[-i]\) to true and set \(C[-i]=f(i)+1\)


after iterating completely through A, until i=n, we construct when to buy cards using this algorithm.

\begin{algorithmic}[1]\label{3.2}
    \State \(D\) is len \(n\) array w/ index 1
    \State \(i=1\)
    \While{\(i<n+1\)}
        \If{B[i]}
            \State D[i]=True
            \State i=C[i]
        \EndIf
    \EndWhile
\end{algorithmic}

one should buy bahncards on the dates \(d_i\) if D[i]=1 for the optimal solution.

note that alg~\ref{3.1} requires time \(O(n)\) to run. the first term runs in \(O(1)\), the second term runs in \(O(n)\) due to the summation and \(f(i)\). note that accessing values in \(A\) takes constant time. since the loop runs eq~\ref{3.1} \(n\) times, the runtime is \(O(n^2)\)

finally,~\ref{3.2} is also run in O(n)

thus the whole algorithm runs in polytime




\end{enumerate}








\end{document}

